{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Basic example\n",
    "In this tutorial, it will be shown how to create data set from any source of data. It will also be shown how to create PDF object from a given set of parameters, and how to generate sample from it and fit it accordingly. Before doing any operation with the minkit package, it is recommended to impot it an call the \"initialize\" function. This will define the backend where the operations will be done (CPU, CUDA or OpenCL). By default it runs on CPU.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import minkit\n",
    "minkit.initialize()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating a data set\n",
    "Data sets can be constructed in many different manners. In this tutorial we will work in the 1-D case, which is also the most common situation. First we need to define the parameter associated to the data. In our case, it will be considered to have values between -5 and +5.\n",
    "These bounds will define the valid range for the different operations of the PDF involving it. The data set can be easily constructed using calling"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "x = minkit.Parameter('x', bounds=(-5, +5))\n",
    "raw = np.random.normal(0, 1, 10000)\n",
    "real_data = minkit.DataSet.from_array(raw, x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now the data set contains values following a Gaussian distribution between -5 and +5."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating a PDF\n",
    "Creating a PDF needs to define previously a set of parameters that rule the behaviour of the function. Let's take a closer look to our data parameter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Parameter(name=x, value=None, bounds=[-5.  5.], error=0.0, constant=False)\n"
     ]
    }
   ],
   "source": [
    "print(x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As you can see, the created parameter has information about the name, value, bounds, its error, and whether it must be considered as constant (something important when doing fits).\n",
    "We will now create a Gaussian function. A Gaussian function also needs a parameter corresponding to the center, and another for the standard deviation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = minkit.Parameter('c', value=0.)\n",
    "s = minkit.Parameter('s', value=1.)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The PDF is constructed taking these parameters as input arguments, together with a name, that identifies the new PDF object."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "g = minkit.Gaussian('g', x, c, s)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Generating data\n",
    "Let's now create some data, which can be easily done using the \"generate\" method of the newly created PDF."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "data = g.generate(10000)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This creates a new data set, that in this case only has one associated data parameter. It is easy to plot the output since we can access the data for each data parameter as a dictionary."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([-0.30125186, -0.52957012, -0.85223453, ..., -1.22266328,\n",
       "        0.50664938,  0.12672492])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data['x']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It is important to note that if we are working on a backend involving GPUs, then it is necessary to copy the contents to the CPU before working with numpy or matplotlib. This can be done with the \"extract_ndarray\" function, and is a good practice to use it wherever we work with exclusively CPU operations, since changing from one backend to the other will become trivial. The function is included in the \"aop\" object, which allows to do operations independently on the backend. In this case, the returned object will be the same as in the previous operation.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([-0.30125186, -0.52957012, -0.85223453, ..., -1.22266328,\n",
       "        0.50664938,  0.12672492])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "minkit.aop.extract_ndarray(data['x'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Plotting the results\n",
    "In order to overlay the PDF, it must be renormalized. This is done with \"scale_pdf_values\", in such a way that we can define as many points as we want to evaluate the PDF, since the PDF will always appear normalized."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "values, edges, _ = plt.hist(minkit.aop.extract_ndarray(data['x']), bins=100, range=x.bounds, histtype='step') # Plot the data\n",
    "l = np.linspace(*x.bounds, 1000)\n",
    "f = g(minkit.DataSet.from_array(l, x)) # Evaluate the PDF in these bins\n",
    "sf = minkit.scale_pdf_values(f, values, edges) # Scale the values of the PDF\n",
    "plt.plot(l, minkit.aop.extract_ndarray(sf)); # Plot the PDF"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Running a simple fit\n",
    "Let's now fit the data. The process of generating a sample following a distribution from a PDF and fitting it afterwards to the same function is very common in order to test for fit estability. In order to do this, first we must initialize a minimizer. These are declared within a context, since some machinery is activated behind your back in order to enable caches for constant PDFs or interpolation maps. It is very important that we do not modify the values of our PDF within this context, since it may lead to undefined behaviour."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "------------------------------------------------------------------\n",
      "| FCN = 2.843E+04               |      Ncalls=90 (90 total)      |\n",
      "| EDM = 5.19E-10 (Goal: 1E-05)  |            up = 1.0            |\n",
      "------------------------------------------------------------------\n",
      "|  Valid Min.   | Valid Param.  | Above EDM | Reached call limit |\n",
      "------------------------------------------------------------------\n",
      "|     True      |     True      |   False   |       False        |\n",
      "------------------------------------------------------------------\n",
      "| Hesse failed  |   Has cov.    | Accurate  | Pos. def. | Forced |\n",
      "------------------------------------------------------------------\n",
      "|     False     |     True      |   True    |   True    | False  |\n",
      "------------------------------------------------------------------\n",
      "------------------------------------------------------------------------------------------\n",
      "|   | Name |   Value   | Hesse Err | Minos Err- | Minos Err+ | Limit-  | Limit+  | Fixed |\n",
      "------------------------------------------------------------------------------------------\n",
      "| 0 | c    |  -0.005   |   0.010   |            |            |   -1    |    1    |       |\n",
      "| 1 | s    |   1.002   |   0.007   |            |            |   0.1   |    5    |       |\n",
      "------------------------------------------------------------------------------------------\n"
     ]
    }
   ],
   "source": [
    "c.bounds = (-1, +1)\n",
    "s.bounds = (0.1, 5)\n",
    "with minkit.unbinned_minimizer('uml', g, data, minimizer='minuit') as minimizer:\n",
    "    # Now \"g\" must not be modified\n",
    "    r = minimizer.migrad()\n",
    "    print(r)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first argument to \"unbinned_minimizer\" is the FCN type, which defines the figure of merit to minimize. The second is the PDF and the third is the data set. For this case, the Minuit minimizer is used, so \"minimizer\" becomes the \"Minuit\" class from the iminuit package. We can extract the values of the parameters by calling"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[Parameter(name=c, value=-0.005439842740226131, bounds=[-1.  1.], error=0.010024650436902038, constant=False), Parameter(name=s, value=1.0024964804976442, bounds=[0.1 5. ], error=0.007089428181999369, constant=False)]\n"
     ]
    }
   ],
   "source": [
    "reg = minkit.minuit_to_registry(r)\n",
    "print(reg)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This object will allow us to treat the information from new Parameter objects."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
