'''
Define the way to parse XML files defining PDFs.
'''
import xml.etree.ElementTree as ET
from . import core

__all__ = []

# Main C++ template
CPU_TEMPLATE = '''// Code auto-generated by MinKit
#include <cmath>
using namespace std;
{preamble}

extern "C" {{

  static inline double shared_function( {data}, {params} ) {{

  {function}
  }}

  double function( {data}, {params} ) {{
     return shared_function({data_args}, {params_args});
  }}

  void evaluate( int _len, double *_out, {data_ptrs}, {params} ) {{
     for ( int _i = 0; _i < _len; ++_i )
        _out[_i] = shared_function({data_ptrs_idx}, {params_args});
  }}
}}
'''

# Main GPU template
GPU_TEMPLATE = '''
{preamble}

WITHIN_KERNEL double shared_function( {data}, {params} ) {{

{function}
}}

KERNEL void evaluate( GLOBAL_MEM double *_out, {data_ptrs}, {params} ) {{

  SIZE_T _i = get_global_id(0);

  _out[_i] = shared_function({data_ptrs_idx}, {params_args});
}}
'''

# Template for C++ PDFs with a definite "integral" function
CPU_TEMPLATE_EXTRA = '''
extern "C" {{

  static inline double integral( {params}, {bounds} ) {{

  {integral}
  }}

  void evaluate_binned( int _len, double *_out, {params}, {nedges}, {gaps}, {edges} ) {{

     for ( int _i = 0; _i < _len; ++_i ) {{

     {edges_indices}

       _out[_i] = integral({params_args}, {edges_args_left}, {edges_args_right});
     }}
  }}
}}
'''

# Template for GPU PDFs with a definite "integral" function
GPU_TEMPLATE_EXTRA = '''
WITHIN_KERNEL double integral( {params}, {bounds} ) {{

{integral}
}}

KERNEL void evaluate_binned( GLOBAL_MEM double *_out, {params}, {nedges}, {gaps}, {edges} ) {{

  SIZE_T _i = get_global_id(0);

  {edges_indices}

  _out[_i] = integral({params_args}, {edges_args_left}, {edges_args_right});
}}
'''


def generate_code(xmlfile, backend):
    '''
    Generate the source code needed to compile a PDF.

    :param xmlfile: path to an XML file.
    :type xmlfile: str
    :param backend: backend where the code will be compiled.
    :type backend: str
    :returns: code for either CPU or GPU.
    :rtype: str
    '''
    root = ET.parse(xmlfile).getroot()

    if backend == core.CPU:
        double_ptr = 'double *'
        template = CPU_TEMPLATE
    else:
        # Imposed by reikna
        double_ptr = 'GLOBAL_MEM double *'
        template = GPU_TEMPLATE

    tags = [c.tag for c in root.getchildren()]

    if 'function' not in tags:
        raise RuntimeError('Expected field "function"')

    format_kwargs = {}

    # Parse the parameters
    c = root.find('parameters')
    if c is not None:
        params = list(f'double {v}' for _, v in c.items())
        params_args = list(v for _, v in c.items())
    else:
        params = []
        params_args = []

    c = root.find('variable_parameters')
    if c is not None:
        n, p = tuple(v for _, v in c.items())
        params += [f'int {n}', f'{double_ptr}{p}']
        params_args += [n, p]

    format_kwargs['params'] = ', '.join(params)
    format_kwargs['params_args'] = ', '.join(params_args)

    # Determine whether a preamble is needed
    p = root.find('preamble')
    if p is not None:
        format_kwargs['preamble'] = p.text or ''
    else:
        format_kwargs['preamble'] = ''

    # Process the function
    p = root.find('function')
    format_kwargs['function'] = p.find('code').text

    d = p.find('data')
    format_kwargs['data'] = ', '.join(f'double {v}' for _, v in d.items())
    format_kwargs['data_args'] = ', '.join(v for _, v in d.items())
    format_kwargs['data_ptrs'] = ', '.join(
        f'{double_ptr}{v}' for _, v in d.items())
    format_kwargs['data_ptrs_idx'] = ', '.join(
        f'{v}[_i]' for _, v in d.items())

    # Check if the "integral" field has been filled
    integral = root.find('integral')

    if integral is not None:

        format_kwargs['integral'] = integral.find('code').text

        xml_bounds = integral.find('bounds')

        bounds = ', '.join(f'double {v}' for _, v in xml_bounds.items())

        nd = len(xml_bounds.keys()) // 2

        gaps = ', '.join(f'int _gap{i}' for i in range(nd))

        nedges = ', '.join(f'int _nedges{i}' for i in range(nd))

        edges = ', '.join(f'{double_ptr}_edges{i}' for i in range(nd))

        edges_indices = '\n'.join(
            f'int _ie{i} = (_i / _gap{i}) % _nedges{i};' for i in range(nd))
        edges_args_left = ', '.join(f'_edges{i}[_ie{i}]' for i in range(nd))
        edges_args_right = ', '.join(
            f'_edges{i}[_ie{i} + 1]' for i in range(nd))

        if backend == core.CPU:
            template += CPU_TEMPLATE_EXTRA
        else:
            template += GPU_TEMPLATE_EXTRA

        format_kwargs.update({'bounds': bounds,
                              'gaps': gaps,
                              'nedges': nedges,
                              'edges': edges,
                              'edges_indices': edges_indices,
                              'edges_args_left': edges_args_left,
                              'edges_args_right': edges_args_right})

    return template.format(**format_kwargs)
